<!DOCTYPE html> 
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <title>ФВ Калкулатор</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1020px;
      margin: 20px auto;
    }
    #container {
      display: flex;
      gap: 20px;
    }
    #params {
      width: 320px;
    }
    #buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    button {
      flex: 1 1 45%;
      padding: 10px;
      font-size: 14px;
      cursor: pointer;
    }
    input {
      display: inline-block;
      margin-left: 8px;
      width: calc(100% - 10px);
      box-sizing: border-box;
    }
    .label-row {
      margin-top: 10px;
    }
    canvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      width: 400px;
      height: 300px;
      display: block;
      margin-top: 20px;
    }
    #resultPanel {
      margin-top: 20px;
      font-weight: bold;
      white-space: pre-line;
    }
    #langToggle {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 12px;
      padding: 4px 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>

<h2 id="title">Фотоволтаичен Калкулатор с Постоянни Панели</h2>

<div id="container">
  <div id="params">
    <div class="label-row" id="labelLength">
      <span id="labelTextLength">Дължина на панела (мм):</span>
      <input type="number" id="length" value="2278" />
    </div>

    <div class="label-row" id="labelWidth">
      <span id="labelTextWidth">Широчина на панела (мм):</span>
      <input type="number" id="width" value="1134" />
    </div>

    <div class="label-row" id="labelTilt">
      <span id="labelTextTilt">Ъгъл на наклон (°):</span>
      <input type="number" id="tilt" value="0" />
    </div>

    <div class="label-row" id="labelPower">
      <span id="labelTextPower">Мощност на панела (kWp):</span>
      <input type="number" id="power" value="580" />
    </div>

    <div class="label-row" id="labelGapH">
      <span id="labelTextGapH">Хоризонтален отстъп (м):</span>
      <input type="number" id="gapH" value="0.02" step="0.01" />
    </div>

    <div class="label-row" id="labelGapV">
      <span id="labelTextGapV">Вертикален отстъп (м):</span>
      <input type="number" id="gapV" value="0.02" step="0.01" />
    </div>

    <div id="buttons">
      <button id="rotateBtn">Въртене: Изключено</button>
      <button id="closePolygonBtn" style="display:none;">Затвори полигона</button>
      <button id="clearBtn">Изчисти</button>
      <button id="deleteBtn">Изтрий избраните панели</button>
    </div>
  </div>

  <div>
    <canvas id="layoutCanvas" width="400" height="300"></canvas>
    <div id="resultPanel"></div>
  </div>
</div>

<button id="langToggle">EN</button>

<script>
/* ===================== ЕЗИКОВА ЧАСТ ===================== */
let currentLang = 'bg';

const translations = {
  bg: {
    title: "Фотоволтаичен Калкулатор с Постоянни Панели",
    labelLength: "Дължина на панела (мм):",
    labelWidth: "Широчина на панела (мм):",
    labelTilt: "Ъгъл на наклон (°):",
    labelPower: "Мощност на панела (kWp):",
    labelGapH: "Хоризонтален отстъп (м):",
    labelGapV: "Вертикален отстъп (м):",
    rotateOn: "Въртене: Включено",
    rotateOff: "Въртене: Изключено",
    drawOn: "Режим рисуване: Включен",
    drawOff: "Режим рисуване: Изключен",
    closePolygonBtn: "Затвори полигона",
    calcBtn: "Изчисли",
    clearBtn: "Изчисти",
    deleteBtn: "Изтрий избраните панели",
    alertClosePolygon: "Моля, затворете полигона преди изчисление.",
    alertMinPolygonPoints: "Полигонът трябва да има поне 3 точки.",
    resultsTemplate: (totalPanels, totalPower, polygonArea, panelArea, coverage, selCount, selPower) =>
      `Общо панели: ${totalPanels}\nОбща мощност (kWp): ${totalPower.toFixed(2)}\n\n` +
      `Площ на обекта: ${polygonArea.toFixed(2)} м²\nПлощ заета от панели: ${panelArea.toFixed(2)} м²\n` +
      `Процент заетост: ${coverage.toFixed(2)} %\n` +
      (selCount > 0 ? `\nИзбрани панели: ${selCount}\nМощност избрани (kWp): ${selPower.toFixed(2)}` : "")
  },
  en: {
    title: "Photovoltaic Calculator with Fixed Panels",
    labelLength: "Panel Length (mm):",
    labelWidth: "Panel Width (mm):",
    labelTilt: "Tilt Angle (°):",
    labelPower: "Panel Power (kWp):",
    labelGapH: "Horizontal Gap (m):",
    labelGapV: "Vertical Gap (m):",
    rotateOn: "Rotate: On",
    rotateOff: "Rotate: Off",
    drawOn: "Draw Mode: On",
    drawOff: "Draw Mode: Off",
    closePolygonBtn: "Close Polygon",
    calcBtn: "Calculate",
    clearBtn: "Clear",
    deleteBtn: "Delete Selected Panels",
    alertClosePolygon: "Please close the polygon before calculating.",
    alertMinPolygonPoints: "Polygon must have at least 3 points.",
    resultsTemplate: (totalPanels, totalPower, polygonArea, panelArea, coverage, selCount, selPower) =>
      `Total Panels: ${totalPanels}\nTotal Power (kWp): ${totalPower.toFixed(2)}\n\n` +
      `Area of Object: ${polygonArea.toFixed(2)} m²\nArea Covered by Panels: ${panelArea.toFixed(2)} m²\n` +
      `Coverage Percentage: ${coverage.toFixed(2)} %\n` +
      (selCount > 0 ? `\nSelected Panels: ${selCount}\nSelected Power (kWp): ${selPower.toFixed(2)}` : "")
  }
};

function updateLanguage() {
  const tr = translations[currentLang];
  document.getElementById('title').innerText = tr.title;
  document.getElementById('labelTextLength').innerText = tr.labelLength;
  document.getElementById('labelTextWidth').innerText = tr.labelWidth;
  document.getElementById('labelTextTilt').innerText = tr.labelTilt;
  document.getElementById('labelTextPower').innerText = tr.labelPower;
  document.getElementById('labelTextGapH').innerText = tr.labelGapH;
  document.getElementById('labelTextGapV').innerText = tr.labelGapV;
  document.getElementById('clearBtn').innerText = tr.clearBtn;

  // налични бутони
  document.getElementById('rotateBtn').innerText = rotate ? tr.rotateOn : tr.rotateOff;
  const drawBtnEl = document.getElementById('drawBtn'); // може да липсва
  if (drawBtnEl) drawBtnEl.innerText = drawMode ? tr.drawOn : tr.drawOff;

  document.getElementById('closePolygonBtn').innerText = tr.closePolygonBtn;
  document.getElementById('deleteBtn').innerText = tr.deleteBtn;
  document.getElementById('langToggle').innerText = currentLang === 'bg' ? 'EN' : 'BG';

  updateClosePolygonBtn();
  updateResults();
}


document.getElementById('langToggle').onclick = () => {
  currentLang = currentLang === 'bg' ? 'en' : 'bg';
  updateLanguage();
};

function alertLocalized(key) {
  const tr = translations[currentLang];
  const msg = tr[key] || key;
  alert(msg);
}

/* ===================== ЛОГИКА НА КАЛКУЛАТОРА И РИСУВАНЕТО ===================== */

let rotate = false;
let drawMode = true;
let polygonClosed = false;
let points = [];
let panelRects = [];
let selectedPanels = [];

let scale = 1;
let offsetX = 0;
let offsetY = 0;

const canvas = document.getElementById("layoutCanvas");
const ctx = canvas.getContext("2d");
const resultPanel = document.getElementById("resultPanel");

let draggingPoint = null;
let isPanning = false;
let startPan = { x: 0, y: 0 };

// pxToM (можеш да добавиш реален мащаб ако желаеш)
let pxToM_x = 1;
let pxToM_y = 1;

/* Помощни функции */
function toRad(deg) { return deg * Math.PI / 180; }

function polygonArea(poly) {
  if (!poly || poly.length < 3) return 0;
  let area = 0;
  for (let i = 0; i < poly.length; i++) {
    const j = (i + 1) % poly.length;
    area += poly[i].x * poly[j].y;
    area -= poly[j].x * poly[i].y;
  }
  return Math.abs(area / 2);
}

function pointInPolygon(p, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    const intersect = ((yi > p.y) !== (yj > p.y)) &&
      (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function panelInsidePolygon(x, y, w, h, poly) {
  const corners = [
    { x: x, y: y },
    { x: x + w, y: y },
    { x: x, y: y + h },
    { x: x + w, y: y + h }
  ];
  // всички 4 ъгъла трябва да са вътре
  return corners.every(corner => pointInPolygon(corner, poly));
}

function getPolygonBounds(poly) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const p of poly) {
    if (p.x < minX) minX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.x > maxX) maxX = p.x;
    if (p.y > maxY) maxY = p.y;
  }
  return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
}

function getMousePos(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) / scale - offsetX,
    y: (e.clientY - rect.top) / scale - offsetY
  };
}

function getNearbyPoint(pos) {
  const radius = 12 / scale;
  for (let i = 0; i < points.length; i++) {
    const dx = points[i].x - pos.x;
    const dy = points[i].y - pos.y;
    if (dx * dx + dy * dy <= radius * radius) return i;
  }
  return null;
}

/* Рисуване */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(offsetX * scale, offsetY * scale);
  ctx.scale(scale, scale);

  // Полигон
  if (points.length > 0) {
    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = polygonClosed ? "#007700" : "#aa0000";
    ctx.fillStyle = polygonClosed ? "rgba(0,128,0,0.12)" : "rgba(255,0,0,0.12)";
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    if (polygonClosed) ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // дължини по страните (в "метри" - зависи от pxToM)
    ctx.fillStyle = "black";
    ctx.font = (12 / scale) + "px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";

    for (let i = 0; i < points.length; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % points.length];
      if (!polygonClosed && i === points.length - 1) break;
      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;
      const dx_m = Math.abs(p2.x - p1.x) * pxToM_x;
      const dy_m = Math.abs(p2.y - p1.y) * pxToM_y;
      const dist_m = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
      const distText = dist_m.toFixed(2) + (currentLang === 'bg' ? " м" : " m");
      ctx.fillText(distText, midX, midY - 5 / scale);
    }

    // точки
    ctx.fillStyle = "#000";
    for (const p of points) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6 / scale, 0, 2 * Math.PI);
      ctx.fill();
    }
  }

  // панели
  for (let i = 0; i < panelRects.length; i++) {
    const p = panelRects[i];
    ctx.fillStyle = selectedPanels.includes(i) ? "rgba(255,165,0,0.8)" : "rgba(0,100,255,0.7)";
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 1 / scale;
    ctx.strokeRect(p.x, p.y, p.w, p.h);
  }

  ctx.restore();
}

/* Събития на canvas */
canvas.addEventListener("mousedown", (e) => {
  const pos = getMousePos(e);
  if (e.button === 2) { // дясно копче -> пан
    isPanning = true;
    startPan = { x: e.clientX, y: e.clientY };
    return;
  }
  draggingPoint = getNearbyPoint(pos);
});

canvas.addEventListener("mousemove", (e) => {
  if (isPanning) {
    offsetX += (e.clientX - startPan.x) / scale;
    offsetY += (e.clientY - startPan.y) / scale;
    startPan = { x: e.clientX, y: e.clientY };
    draw();
    return;
  }
  if (draggingPoint !== null) {
    const pos = getMousePos(e);
    points[draggingPoint] = pos;
    panelRects = [];
    selectedPanels = [];
if (polygonClosed) {
    calculate();
    updateResults();
  }
    draw();
  }
});

canvas.addEventListener("mouseup", () => {
  draggingPoint = null;
  isPanning = false;
});

canvas.addEventListener("click", (e) => {
  const pos = getMousePos(e);

  // ако вече има точки и кликът е близо до първата точка
  if (!polygonClosed && points.length > 2) {
  const firstPoint = points[0];
  const dx = pos.x - firstPoint.x;
  const dy = pos.y - firstPoint.y;
  const radius = 12 / scale; // същия радиус като при getNearbyPoint
  if (dx * dx + dy * dy <= radius * radius) {
    polygonClosed = true;
    draw();
    calculate();    // <-- добавено извикване тук
    updateResults();
    return; // спираме по-нататъшното добавяне на точки
  }
}


  // селекция на панел
  const clickedPanelIndex = panelRects.findIndex(p =>
    pos.x >= p.x && pos.x <= p.x + p.w &&
    pos.y >= p.y && pos.y <= p.y + p.h
  );
  if (clickedPanelIndex !== -1) {
    const idxInSel = selectedPanels.indexOf(clickedPanelIndex);
    if (idxInSel === -1) selectedPanels.push(clickedPanelIndex);
    else selectedPanels.splice(idxInSel, 1);
    draw();
    updateResults();
    return;
  }

  // добавяне точки ако сме в drawMode
  if (!drawMode || polygonClosed || e.button !== 0) return;
  if (getNearbyPoint(pos) === null) {
    points.push(pos);
    draw();
  }
});


canvas.addEventListener("dblclick", (e) => {
  const pos = getMousePos(e);
  const idx = getNearbyPoint(pos);
  if (idx !== null) {
    points.splice(idx, 1);
    polygonClosed = false;
    panelRects = [];
    selectedPanels = [];
    draw();
    updateResults();
  }
});

canvas.addEventListener("contextmenu", (e) => e.preventDefault());

canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
  const center = getPolygonCenter();
  const centerScreenX = (center.x + offsetX) * scale;
  const centerScreenY = (center.y + offsetY) * scale;
  scale *= zoomFactor;
  offsetX = (centerScreenX / scale) - center.x;
  offsetY = (centerScreenY / scale) - center.y;
  draw();
});

function getPolygonCenter() {
  if (points.length === 0) return { x: canvas.width/(2*scale) - offsetX, y: canvas.height/(2*scale) - offsetY };
  let sumX = 0, sumY = 0;
  for (const p of points) { sumX += p.x; sumY += p.y; }
  return { x: sumX / points.length, y: sumY / points.length };
}

/* =================================== Управление на бутоните =================================== */

document.getElementById("rotateBtn").addEventListener("click", () => {
  rotate = !rotate;
  updateLanguage();

  // ако има затворен полигон -> веднага преизчисли и прерисувай
  if (polygonClosed) {
    calculate();
    updateResults();
  }
});



document.getElementById("closePolygonBtn").addEventListener("click", () => {
  if (points.length < 3) {
    alertLocalized('alertMinPolygonPoints');
    return;
  }
  polygonClosed = true;
  calculate();   // <-- добавено
  draw();
  updateResults();
});





document.getElementById("deleteBtn").addEventListener("click", () => {
  if (selectedPanels.length > 0) {
    // премахваме в обратен индексен ред за по-сигурно (въпреки че filter работи)
    panelRects = panelRects.filter((_, i) => !selectedPanels.includes(i));
    selectedPanels = [];
    updateResults();
    draw();
  }
});
document.getElementById("clearBtn").addEventListener("click", () => {
  console.log("Изчисти натиснат!");
  points = [];
  polygonClosed = false;
  panelRects = [];
  selectedPanels = [];
  updateResults();
  draw();
});


/* =================================== Изчисления =================================== */

function calculate() {
  if (!polygonClosed || points.length < 3) {
    alertLocalized('alertClosePolygon');
    return;
  }

  panelRects = [];
  selectedPanels = [];

  const panelLengthMm = Number(document.getElementById("length").value) || 0;
  const panelWidthMm = Number(document.getElementById("width").value) || 0;
  const panelPower = Number(document.getElementById("power").value) || 0;
  const panelTilt = Number(document.getElementById("tilt").value) || 0;
  const gapH = Number(document.getElementById("gapH").value) || 0;
  const gapV = Number(document.getElementById("gapV").value) || 0;

  let panelWidthM = panelWidthMm / 1000;
  let panelLengthM = panelLengthMm / 1000;

  if (rotate) [panelWidthM, panelLengthM] = [panelLengthM, panelWidthM];

  const bounds = getPolygonBounds(points);

  // за момента 1 canvas unit = 1 m (можеш да промениш ако имаш реален мащаб)
  pxToM_x = 1;
  pxToM_y = 1;

  const startX = bounds.minX;
  const startY = bounds.minY;

  const stepX = panelWidthM + gapH;
  const stepY = panelLengthM + gapV;

  // обходим
  for (let y = startY; y + panelLengthM <= bounds.maxY + 1e-9; y += stepY) {
    for (let x = startX; x + panelWidthM <= bounds.maxX + 1e-9; x += stepX) {
      if (panelInsidePolygon(x, y, panelWidthM, panelLengthM, points)) {
        panelRects.push({ x, y, w: panelWidthM, h: panelLengthM });
      }
    }
  }

  updateResults();
  draw();
}

/* =================================== Резултати =================================== */

function updateResults() {
  const tr = translations[currentLang];
  let totalPanels = panelRects.length;
  const panelPower = Number(document.getElementById("power").value) || 0;
  const totalPower = totalPanels * panelPower / 1000;

  let polygonAreaM2 = polygonArea(points);
  let totalPanelArea = panelRects.reduce((sum, p) => sum + (p.w * p.h), 0);
  let coveragePercent = polygonAreaM2 > 0 ? (totalPanelArea / polygonAreaM2) * 100 : 0;

  const selCount = selectedPanels.length;
  let selPower = selCount * panelPower / 1000;

  const info = tr.resultsTemplate(totalPanels, totalPower, polygonAreaM2, totalPanelArea, coveragePercent, selCount, selPower);
  resultPanel.innerText = info;
}

/* Покажи/скрий бутона Close Polygon в зависимост от drawMode */
function updateClosePolygonBtn() {
  const btn = document.getElementById("closePolygonBtn");
  if (drawMode) btn.style.display = "inline-block";
  else btn.style.display = "none";
}

/* Инициални извиквания */
updateLanguage();
draw();

</script>

</body>
</html>
